#ifndef CALCULATIONS_H
#define CALCULATIONS_H

#include <vector>
#include <string>
#include <cmath>    // Для std::sqrt
#include <iostream> // Для std::cerr

// Параметры симуляции
struct SimulationParameters {
    double G = 1.0;
    double M = 1.0;
    double CENTRAL_BODY_RADIUS = 0.01;
    double DRAG_COEFFICIENT = 0.05;
    double THRUST_COEFFICIENT = 0.00;
    double DT = 0.001;
    int STEPS = 100000;

    struct InitialStateParams {
        double x = 1.5;
        double y = 0.0;
        double vx = 0.0;
        double vy = 0.8;
    } initialState;
};

// Состояние системы
struct State {
    double x, y, vx, vy;
};

class Calculations {
public:
    Calculations(); // Конструктор по умолчанию

    // Основной метод для запуска симуляции
    std::vector<State> runSimulation(const SimulationParameters& params);

private:
    // Правая часть системы дифференциальных уравнений
    static State derivatives(const State& s, const SimulationParameters& params);

    // Один шаг интегрирования методом Рунге-Кутты 4-го порядка
    static State rungeKuttaStep(const State& s, double dt, const SimulationParameters& params);
};

#endif // CALCULATIONS_H

#include "Calculations.h"

Calculations::Calculations() {
    // Конструктор может быть пустым, если нет специфической инициализации
}

// Основной метод для запуска симуляции
std::vector<State> Calculations::runSimulation(const SimulationParameters& params) {
    State currentState;
    currentState.x = params.initialState.x;
    currentState.y = params.initialState.y;
    currentState.vx = params.initialState.vx;
    currentState.vy = params.initialState.vy;

    std::vector<State> trajectoryStates; // Теперь храним полные состояния
    trajectoryStates.reserve(static_cast<size_t>(params.STEPS) + 1);
    trajectoryStates.push_back(currentState); // Добавляем начальное состояние

    double initial_r_squared = currentState.x * currentState.x + currentState.y * currentState.y;
    if (initial_r_squared < params.CENTRAL_BODY_RADIUS * params.CENTRAL_BODY_RADIUS) {
        std::cout << "Столкновение: начальная позиция (" << currentState.x << ", " << currentState.y
            << ") внутри радиуса центрального тела (" << params.CENTRAL_BODY_RADIUS << ").\n";
        return trajectoryStates;
    }

    for (int i = 0; i < params.STEPS; ++i) {
        currentState = rungeKuttaStep(currentState, params.DT, params); // Передаем params явно

        trajectoryStates.push_back(currentState); // Добавляем полное состояние

        double r_squared = currentState.x * currentState.x + currentState.y * currentState.y;
        if (r_squared < params.CENTRAL_BODY_RADIUS * params.CENTRAL_BODY_RADIUS) {
            std::cout << "Столкновение обнаружено на шаге " << i + 1
                << " после вычисления. Координаты: (" << currentState.x << ", " << currentState.y
                << "), r = " << std::sqrt(r_squared) << "\n";
            break;
        }
    }
    return trajectoryStates;
}

// Правая часть системы дифференциальных уравнений
State Calculations::derivatives(const State& s, const SimulationParameters& params) {
    double r_squared = s.x * s.x + s.y * s.y;
    if (r_squared == 0) {
        return { s.vx, s.vy, 0, 0 };
    }
    double r = std::sqrt(r_squared);
    double r_cubed = r_squared * r;

    double common_factor_gravity = -params.G * params.M / r_cubed;
    double net_propulsion_factor = params.THRUST_COEFFICIENT - params.DRAG_COEFFICIENT;

    double ax = common_factor_gravity * s.x + net_propulsion_factor * s.vx;
    double ay = common_factor_gravity * s.y + net_propulsion_factor * s.vy;
    return { s.vx, s.vy, ax, ay };
}

// Один шаг интегрирования методом Рунге-Кутты 4-го порядка
State Calculations::rungeKuttaStep(const State& s, double dt, const SimulationParameters& params) {
    State k1 = derivatives(s, params);

    State s_temp_k2 = {
        s.x + dt * k1.x / 2.0,
        s.y + dt * k1.y / 2.0,
        s.vx + dt * k1.vx / 2.0,
        s.vy + dt * k1.vy / 2.0
    };
    State k2 = derivatives(s_temp_k2, params);

    State s_temp_k3 = {
        s.x + dt * k2.x / 2.0,
        s.y + dt * k2.y / 2.0,
        s.vx + dt * k2.vx / 2.0,
        s.vy + dt * k2.vy / 2.0
    };
    State k3 = derivatives(s_temp_k3, params);

    State s_temp_k4 = {
        s.x + dt * k3.x,
        s.y + dt * k3.y,
        s.vx + dt * k3.vx,
        s.vy + dt * k3.vy
    };
    State k4 = derivatives(s_temp_k4, params);

    return {
        s.x + dt / 6.0 * (k1.x + 2.0 * k2.x + 2.0 * k3.x + k4.x),
        s.y + dt / 6.0 * (k1.y + 2.0 * k2.y + 2.0 * k3.y + k4.y),
        s.vx + dt / 6.0 * (k1.vx + 2.0 * k2.vx + 2.0 * k3.vx + k4.vx),
        s.vy + dt / 6.0 * (k1.vy + 2.0 * k2.vy + 2.0 * k3.vy + k4.vy)
    };
}

#pragma once
#ifndef TRAJECTORYVISUALIZER_H
#define TRAJECTORYVISUALIZER_H

#include <SFML/Graphics.hpp>
#include <vector>
#include <string>
#include <cmath>    // Для std::sqrt, std::min, std::max
#include <iostream> // Для std::cerr, std::cout
#include <fstream>  // Для std::ifstream, std::ofstream
#include <sstream>  // Для std::istringstream, std::ostringstream
#include <iomanip>  // Для std::fixed, std::setprecision
#include <algorithm> // Для std::min, std::max (дублирование, но не страшно)

// Используем тот же тип данных, что и в Calculations.h
// Если вынести в общий "types.h", то можно будет включать его.
using WorldTrajectoryPoint = std::pair<double, double>;
using WorldTrajectoryData = std::vector<WorldTrajectoryPoint>;


class TrajectoryVisualizer {
public:
    TrajectoryVisualizer(unsigned int width, unsigned int height, const std::string& windowTitle = "Trajectory Visualizer");

    void setData(const WorldTrajectoryData& data);
    bool loadDataFromFile(const std::string& filename);
    void run();
    void resetViewAndAnimation();

    bool saveTrajectoryToFile(const std::string& filename) const; 

private:
    // --- Константы визуализации ---
    // Их можно сделать static constexpr членами класса или оставить как есть, если они не меняются
    static constexpr float DEFAULT_SCALE = 150.0f;
    static constexpr unsigned int DEFAULT_POINTS_PER_FRAME = 1u;
    static constexpr unsigned int MIN_POINTS_PER_FRAME = 1u;
    static constexpr unsigned int MAX_POINTS_PER_FRAME = 2048u;
    static constexpr unsigned int ANIMATION_SPEED_MULTIPLIER = 2;
    const std::string FONT_FILENAME = "arial.ttf";
    static constexpr unsigned int INFO_TEXT_CHAR_SIZE = 16;
    static constexpr float CENTER_POINT_RADIUS = 5.0f;
    static constexpr float TRAJECTORY_START_POINT_RADIUS = 2.0f;
    static constexpr float ZOOM_FACTOR_STEP = 1.3f;

    sf::RenderWindow m_window;
    WorldTrajectoryData m_worldTrajectoryData;
    std::vector<sf::Vertex> m_screenTrajectory;

    float m_scale;
    sf::Vector2f m_offset;
    sf::Vector2f m_screenCenter;

    size_t m_currentPointIndex;
    unsigned int m_pointsPerFrame;
    bool m_isPaused;
    bool m_showAllPointsImmediately;

    sf::Font m_font;
    sf::Text m_infoText;

    bool m_isDragging;
    sf::Vector2i m_lastMousePos;

    // Приватные методы
    sf::Vector2f toScreenCoords(double worldX, double worldY) const;
    sf::Vector2f toWorldCoords(sf::Vector2f screenPos) const;
    void recalculateScreenTrajectory();
    void setupInfoText();
    void updateInfoText();
    void handleEvent(const sf::Event& event);
    void handleKeyPress(const sf::Event::KeyEvent& keyEvent);
    void updateAnimation();
    void draw();
};

#endif // TRAJECTORYVISUALIZER_H

#include "TrajectoryVisualizer.h"

// --- Инициализация статических констант (если они объявлены как static в .h) ---
// constexpr float TrajectoryVisualizer::DEFAULT_SCALE; // И т.д. для всех static constexpr
// Но для литеральных типов static constexpr можно инициализировать прямо в .h (C++17+)
// Если компилятор старый, то так:
// const float TrajectoryVisualizer::DEFAULT_SCALE = 150.0f;
// const unsigned int TrajectoryVisualizer::DEFAULT_POINTS_PER_FRAME = 1u; 
// ... и так далее для других ...

TrajectoryVisualizer::TrajectoryVisualizer(unsigned int width, unsigned int height, const std::string& windowTitle)
    : m_window(sf::VideoMode(width, height), windowTitle, sf::Style::Default), // Используем L"" для кириллицы в заголовке, если нужно
    m_scale(DEFAULT_SCALE),
    m_offset(0.f, 0.f),
    m_screenCenter(static_cast<float>(width) / 2.f, static_cast<float>(height) / 2.f),
    m_currentPointIndex(0),
    m_pointsPerFrame(DEFAULT_POINTS_PER_FRAME),
    m_isPaused(false),
    m_showAllPointsImmediately(false),
    m_isDragging(false) {
    m_window.setFramerateLimit(60);
    setupInfoText();
}

void TrajectoryVisualizer::setData(const WorldTrajectoryData& data) {
    m_worldTrajectoryData = data;
    resetViewAndAnimation();
    // recalculateScreenTrajectory(); // Вызывается внутри resetViewAndAnimation
}

bool TrajectoryVisualizer::loadDataFromFile(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr << "TrajectoryVisualizer: Ошибка: не удалось открыть файл траектории " << filename << "\n";
        return false;
    }
    WorldTrajectoryData data;
    std::string line;
    while (std::getline(file, line)) {
        std::istringstream iss(line);
        double x, y;
        if (iss >> x >> y) {
            data.emplace_back(x, y);
        }
        else {
            std::cerr << "TrajectoryVisualizer: Предупреждение: неверный формат строки в файле: " << line << "\n";
        }
    }
    file.close(); // Закрываем файл
    if (data.empty()) {
        std::cerr << "TrajectoryVisualizer: Ошибка: файл " << filename << " пуст или не содержит корректных данных.\n";
        return false;
    }
    setData(data);
    return true;
}

void TrajectoryVisualizer::run() {
    if (m_worldTrajectoryData.empty()) {
        std::cerr << "TrajectoryVisualizer: Нет данных для визуализации. Загрузите данные.\n";
        // Можно просто показать пустое окно с сообщением
        bool dataNotLoaded = true;
        while (m_window.isOpen() && dataNotLoaded) {
            sf::Event event{};
            while (m_window.pollEvent(event)) {
                if (event.type == sf::Event::Closed) m_window.close();
                if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Escape) m_window.close();
            }
            updateInfoText(); // Обновит текст, который может содержать сообщение об ошибке
            m_window.clear(sf::Color::Black);
            m_window.draw(m_infoText); // Показать инфо-текст (можно изменить его содержимое)
            m_window.display();
            if (!m_worldTrajectoryData.empty()) dataNotLoaded = false; // Если данные загрузились в другом потоке/способом
        }
        if (!m_window.isOpen()) return; // Если окно было закрыто
    }

    while (m_window.isOpen()) {
        sf::Event event{};
        while (m_window.pollEvent(event)) {
            handleEvent(event);
        }
        updateAnimation();
        updateInfoText();
        draw();
    }
}

void TrajectoryVisualizer::resetViewAndAnimation() {
    m_scale = DEFAULT_SCALE;
    m_offset = { 0.f, 0.f };
    m_isPaused = false;
    m_showAllPointsImmediately = false;
    m_pointsPerFrame = DEFAULT_POINTS_PER_FRAME;
    m_currentPointIndex = m_worldTrajectoryData.empty() ? 0 : 1;
    recalculateScreenTrajectory();
}

sf::Vector2f TrajectoryVisualizer::toScreenCoords(double worldX, double worldY) const {
    return {
        m_screenCenter.x + m_offset.x + static_cast<float>(worldX) * m_scale,
        m_screenCenter.y + m_offset.y - static_cast<float>(worldY) * m_scale
    };
}

sf::Vector2f TrajectoryVisualizer::toWorldCoords(sf::Vector2f screenPos) const {
    return {
        (screenPos.x - m_screenCenter.x - m_offset.x) / m_scale,
       -(screenPos.y - m_screenCenter.y - m_offset.y) / m_scale
    };
}

void TrajectoryVisualizer::recalculateScreenTrajectory() {
    m_screenTrajectory.clear();
    if (m_worldTrajectoryData.empty()) return;

    m_screenTrajectory.reserve(m_worldTrajectoryData.size());
    for (const auto& world_point : m_worldTrajectoryData) {
        m_screenTrajectory.emplace_back(toScreenCoords(world_point.first, world_point.second), sf::Color::White);
    }

    if (!m_showAllPointsImmediately) {
        m_currentPointIndex = std::min(m_currentPointIndex, m_screenTrajectory.size());
        if (m_currentPointIndex == 0 && !m_screenTrajectory.empty()) {
            m_currentPointIndex = 1;
        }
    }
    else {
        m_currentPointIndex = m_screenTrajectory.size();
    }
}

void TrajectoryVisualizer::setupInfoText() {
    if (!m_font.loadFromFile(FONT_FILENAME)) {
        std::cerr << "TrajectoryVisualizer: Ошибка: не удалось загрузить шрифт " << FONT_FILENAME << "\n";
    }
    m_infoText.setFont(m_font);
    m_infoText.setCharacterSize(INFO_TEXT_CHAR_SIZE);
    m_infoText.setFillColor(sf::Color::Yellow);
    m_infoText.setPosition(10.f, 10.f);
}

void TrajectoryVisualizer::updateInfoText() {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(2);
    oss << "Scale: " << m_scale << "\n";
    oss << "Offset: (" << m_offset.x << ", " << m_offset.y << ")\n";
    oss << "Points drawn: " << m_currentPointIndex << "/" << m_worldTrajectoryData.size() << "\n";
    oss << "Animation: " << (m_isPaused ? "Paused" : "Running")
        << " (" << m_pointsPerFrame << " pts/frame)\n";
    oss << "Controls:\n";
    oss << "  Mouse Wheel: Zoom\n";
    oss << "  Right Mouse Drag: Pan\n";
    oss << "  P: Pause/Resume animation\n";
    oss << "  F: Toggle full trajectory\n";
    oss << "  +/-: Change animation speed\n";
    oss << "  R: Reset view & animation\n";
    oss << "  Esc: Exit";
    m_infoText.setString(oss.str()); // Для sf::Text лучше использовать sf::String или L"" если есть кириллица
    // но здесь только ASCII, так что oss.str() должен работать.
    // Для надежности можно: m_infoText.setString(sf::String::fromUtf8(oss.str().c_str()));
}

void TrajectoryVisualizer::handleEvent(const sf::Event& event) {
    switch (event.type) {
    case sf::Event::Closed:
        m_window.close();
        break;
    case sf::Event::Resized:
    {
        sf::FloatRect visibleArea(0, 0, static_cast<float>(event.size.width), static_cast<float>(event.size.height));
        m_window.setView(sf::View(visibleArea));
        m_screenCenter = { event.size.width / 2.f, event.size.height / 2.f };
        recalculateScreenTrajectory();
    }
    break;
    case sf::Event::KeyPressed:
        handleKeyPress(event.key);
        break;
    case sf::Event::MouseWheelScrolled:
        if (event.mouseWheelScroll.wheel == sf::Mouse::VerticalWheel && event.mouseWheelScroll.delta != 0) { // Проверяем тип колеса
            sf::Vector2f worldPosBeforeZoom = toWorldCoords(static_cast<sf::Vector2f>(sf::Mouse::getPosition(m_window)));
            float zoomFactor = (event.mouseWheelScroll.delta > 0) ? ZOOM_FACTOR_STEP : 1.0f / ZOOM_FACTOR_STEP;
            m_scale *= zoomFactor;
            sf::Vector2f worldPosAfterZoom = toWorldCoords(static_cast<sf::Vector2f>(sf::Mouse::getPosition(m_window)));
            m_offset.x += (worldPosAfterZoom.x - worldPosBeforeZoom.x) * m_scale;
            m_offset.y += (worldPosAfterZoom.y - worldPosBeforeZoom.y) * m_scale;
            recalculateScreenTrajectory();
        }
        break;
    case sf::Event::MouseButtonPressed:
        if (event.mouseButton.button == sf::Mouse::Right) {
            m_isDragging = true;
            m_lastMousePos = sf::Mouse::getPosition(m_window);
        }
        break;
    case sf::Event::MouseButtonReleased:
        if (event.mouseButton.button == sf::Mouse::Right) {
            m_isDragging = false;
        }
        break;
    case sf::Event::MouseMoved:
        if (m_isDragging) {
            sf::Vector2i newMousePos = sf::Mouse::getPosition(m_window);
            sf::Vector2f delta = static_cast<sf::Vector2f>(newMousePos - m_lastMousePos);
            m_offset += delta;
            m_lastMousePos = newMousePos;
            recalculateScreenTrajectory();
        }
        break;
    default:
        break;
    }
}

void TrajectoryVisualizer::handleKeyPress(const sf::Event::KeyEvent& keyEvent) {
    if (keyEvent.code == sf::Keyboard::Escape) m_window.close();
    if (keyEvent.code == sf::Keyboard::P) m_isPaused = !m_isPaused;
    if (keyEvent.code == sf::Keyboard::F) {
        m_showAllPointsImmediately = !m_showAllPointsImmediately;
        if (m_showAllPointsImmediately) {
            m_currentPointIndex = m_screenTrajectory.size();
        }
        else {
            m_currentPointIndex = m_screenTrajectory.empty() ? 0 : 1;
        }
    }
    if (keyEvent.code == sf::Keyboard::Add || keyEvent.code == sf::Keyboard::Equal) { // Equal это + на основной клавиатуре
        m_pointsPerFrame = std::min(m_pointsPerFrame * ANIMATION_SPEED_MULTIPLIER, MAX_POINTS_PER_FRAME);
    }
    if (keyEvent.code == sf::Keyboard::Subtract || keyEvent.code == sf::Keyboard::Hyphen) { // Hyphen это - на основной клавиатуре
        m_pointsPerFrame = std::max(m_pointsPerFrame / ANIMATION_SPEED_MULTIPLIER, MIN_POINTS_PER_FRAME);
    }
    if (keyEvent.code == sf::Keyboard::R) resetViewAndAnimation();
}

void TrajectoryVisualizer::updateAnimation() {
    if (!m_isPaused && !m_showAllPointsImmediately && m_currentPointIndex < m_screenTrajectory.size()) {
        m_currentPointIndex = std::min(m_screenTrajectory.size(), m_currentPointIndex + m_pointsPerFrame);
    }
}

void TrajectoryVisualizer::draw() {
    m_window.clear(sf::Color::Black);

    sf::CircleShape centerMassShape(CENTER_POINT_RADIUS);
    centerMassShape.setFillColor(sf::Color::Red);
    centerMassShape.setOrigin(CENTER_POINT_RADIUS, CENTER_POINT_RADIUS);
    centerMassShape.setPosition(toScreenCoords(0, 0));
    m_window.draw(centerMassShape);

    if (!m_screenTrajectory.empty()) {
        size_t pointsToDraw = std::min(m_currentPointIndex, m_screenTrajectory.size());
        if (pointsToDraw >= 2) {
            m_window.draw(&m_screenTrajectory[0], pointsToDraw, sf::LineStrip);
        }
        else if (pointsToDraw == 1) {
            sf::CircleShape firstPointShape(TRAJECTORY_START_POINT_RADIUS);
            firstPointShape.setFillColor(sf::Color::White);
            firstPointShape.setOrigin(TRAJECTORY_START_POINT_RADIUS, TRAJECTORY_START_POINT_RADIUS);
            firstPointShape.setPosition(m_screenTrajectory[0].position);
            m_window.draw(firstPointShape);
        }
    }

    m_window.draw(m_infoText);
    m_window.display();
}

bool TrajectoryVisualizer::saveTrajectoryToFile(const std::string& filename) const {
    if (m_worldTrajectoryData.empty()) {
        std::cerr << "TrajectoryVisualizer: Нет данных траектории для сохранения в файл '" << filename << "'.\n";
        return false; // Возвращаем false, если данных нет
    }

    std::ofstream outputFile(filename);
    if (!outputFile.is_open()) {
        std::cerr << "TrajectoryVisualizer: Ошибка: не удалось открыть файл '" << filename << "' для записи.\n";
        return false;
    }

    // Устанавливаем форматирование для вывода чисел с плавающей точкой
    // для лучшей читаемости и точности в файле
    outputFile << std::fixed << std::setprecision(10); // 10 знаков после запятой

    for (const auto& point : m_worldTrajectoryData) {
        // m_worldTrajectoryData это std::vector<std::pair<double, double>>
        // point.first это x, point.second это y
        outputFile << point.first << " " << point.second << "\n";
    }
        
    outputFile.close(); // Закрываем файл

    if (outputFile.fail()) { // Проверяем, не возникло ли ошибок при записи или закрытии
        std::cerr << "TrajectoryVisualizer: Ошибка при записи или закрытии файла '" << filename << "'.\n";
        return false;
    }

    std::cout << "TrajectoryVisualizer: Траектория (" << m_worldTrajectoryData.size()
        << " точек) успешно сохранена в файл '" << filename << "'.\n";
    return true;
}

#pragma once

#ifndef USERINTERFACE_H
#define USERINTERFACE_H

#include <SFML/Graphics.hpp>
#include <TGUI/TGUI.hpp>
#include "Calculations.h" // Включаем Calculations.h для доступа к State

#include <vector>
#include <string>
#include <iomanip>
#include <sstream>

struct TableRowData {
    float h_days; // Изменено с h_sec на h_days для ясности
    float x, y;
    float Vx, Vy;
};

class UserInterface {
public:
    UserInterface();
    void run();

private:
    static constexpr float INPUT_FIELD_WIDTH = 180.f;
    static constexpr float INPUT_ROW_HEIGHT = 30.f;
    static constexpr float PANEL_PADDING = 10.f;
    static constexpr float WIDGET_SPACING = 10.f;
    static constexpr float HEADER_HEIGHT = 30.f;
    static constexpr float TITLE_HEIGHT = 30.f; // Увеличил для лучшей читаемости заголовков
    static constexpr float SCROLLBAR_WIDTH_ESTIMATE = 18.f;

    void initializeGui();
    
    void loadWidgets();
    void loadLeftPanelWidgets();
    void loadRightPanelWidgets();
    void loadTrajectoryWidgets(tgui::Panel::Ptr parentPanel);
    void loadTableWidgets(tgui::Panel::Ptr parentPanel);
    
    void setupLayout();
    void connectSignals();
    void handleEvents();
    
    void update();
    void render();
    
    void onCalculateButtonPressed();
    void onShowVisualizerButtonPressed(); // <--- НОВЫЙ МЕТОД
    void populateTable(const std::vector<TableRowData>& data);
    
    void drawTrajectoryOnCanvas(sf::RenderTarget& target_rt); // Изменено имя аргумента
    void prepareTrajectoryForDisplay();

    sf::RenderWindow m_window;
    tgui::Gui m_gui;

    
    tgui::Label::Ptr m_inputTitleLabel;
    tgui::EditBox::Ptr m_edit_m;
    tgui::EditBox::Ptr m_edit_M;
    tgui::EditBox::Ptr m_edit_V0;
    tgui::EditBox::Ptr m_edit_T;
    tgui::EditBox::Ptr m_edit_k;
    tgui::EditBox::Ptr m_edit_F;
    tgui::Button::Ptr m_calculateButton;
    tgui::Button::Ptr m_showVisualizerButton; // <--- НОВАЯ КНОПКА
    tgui::Grid::Ptr m_inputControlsGrid;

    tgui::Panel::Ptr m_leftPanel;
    tgui::Panel::Ptr m_rightPanel;
    tgui::Panel::Ptr m_trajectoryContainerPanel;
    tgui::Panel::Ptr m_tableContainerPanel;

    tgui::Label::Ptr m_trajectoryTitleLabel;
    tgui::Canvas::Ptr m_trajectoryCanvas;
    sf::Font m_sfmlFont;

    std::vector<TableRowData> m_currentTableData;
    std::vector<State> m_calculatedStates;
    std::vector<sf::Vertex> m_trajectoryDisplayPoints;
    bool m_trajectoryAvailable;

    // View для канваса, который будет автоматически подгоняться
    sf::View m_fittedCanvasView;

    tgui::Label::Ptr m_tableTitleLabel;
    tgui::Grid::Ptr m_tableHeaderGrid;
    tgui::ScrollablePanel::Ptr m_tableDataPanel;
    tgui::Grid::Ptr m_tableDataGrid;
};

#endif USERINTERFACE_H

#include "UserInterface.h"
#include "TrajectoryVisualizer.h"

#include <iostream> // Для отладки
#include <algorithm> // Для std::min_element, std::max_element
#include <cmath> // для std::pow, std::sqrt

#if defined(_MSC_VER)
#pragma execution_character_set("utf-8")
#endif

// --- Вспомогательная функция для создания строки ввода ---
std::pair<tgui::Label::Ptr, tgui::EditBox::Ptr> createInputRowControls(const sf::String& labelText, float editBoxWidth, float rowHeight) {
    auto label = tgui::Label::create(tgui::String(labelText)); // sf::String с L"" хорошо работает с tgui::Label
    if (label) {
        label->getRenderer()->setTextColor(tgui::Color::Black);
        label->setVerticalAlignment(tgui::Label::VerticalAlignment::Center);
    }

    auto editBox = tgui::EditBox::create();
    if (editBox) {
        editBox->setSize({ editBoxWidth, rowHeight });
    }
    return { label, editBox };
}

// --- Конструктор и инициализация ---
UserInterface::UserInterface()
    : m_window({ 1200, 800 }, L"Расчет траектории движения тела"),
    m_gui(m_window),
    m_trajectoryAvailable(false) {

    m_gui.setFont("arial.ttf");

    // Загрузка шрифта для SFML (используется на Canvas)
    if (!m_sfmlFont.loadFromFile("arial.ttf")) {
        std::cerr << "SFML: Error - Failed to load font 'arial.ttf' for SFML rendering!\n";
    }

    initializeGui();
}

void UserInterface::initializeGui() {
    std::cout << "DEBUG: Initializing GUI..." << std::endl;
    loadWidgets();
    setupLayout(); // Вызываем setupLayout после loadWidgets
    connectSignals();
    populateTable({}); // Начальное пустое состояние таблицы
    std::cout << "DEBUG: GUI Initialized." << std::endl;
}

// --- Загрузка виджетов ---
void UserInterface::loadWidgets() {
    std::cout << "DEBUG: Loading all widgets..." << std::endl;
    loadLeftPanelWidgets();
    loadRightPanelWidgets();
    std::cout << "DEBUG: All widgets loaded." << std::endl;
}

void UserInterface::loadLeftPanelWidgets() {
    m_leftPanel = tgui::Panel::create();
    if (!m_leftPanel) { std::cerr << "Error: Failed to create m_leftPanel" << std::endl; return; }
    m_leftPanel->getRenderer()->setBackgroundColor(tgui::Color(220, 220, 220));
    m_leftPanel->getRenderer()->setBorders({ 1, 1, 1, 1 });
    m_leftPanel->getRenderer()->setBorderColor(tgui::Color::Black);
    m_gui.add(m_leftPanel);

    // 1. Заголовок "Исходные значения"
    m_inputTitleLabel = tgui::Label::create(L"Исходные значения");
    if (!m_inputTitleLabel) { std::cerr << "Error: Failed to create m_inputTitleLabel" << std::endl; return; }
    m_inputTitleLabel->getRenderer()->setTextStyle(tgui::TextStyle::Bold);
    m_inputTitleLabel->setHorizontalAlignment(tgui::Label::HorizontalAlignment::Center);
    m_inputTitleLabel->getRenderer()->setTextColor(tgui::Color::Black);
    m_inputTitleLabel->setSize({ "100% - " + tgui::String::fromNumber(2 * PANEL_PADDING), TITLE_HEIGHT });
    m_inputTitleLabel->setPosition({ PANEL_PADDING, PANEL_PADDING });
    m_leftPanel->add(m_inputTitleLabel);

    // 2. Grid для полей ввода
    m_inputControlsGrid = tgui::Grid::create(); // Используем член класса
    if (!m_inputControlsGrid) { std::cerr << "Error: Failed to create m_inputControlsGrid" << std::endl; return; }
    m_inputControlsGrid->setPosition({ PANEL_PADDING, tgui::bindBottom(m_inputTitleLabel) + WIDGET_SPACING });
    m_leftPanel->add(m_inputControlsGrid);

    unsigned int currentRow = 0;
    // Лямбда для добавления строки в inputControlsGrid
    auto addInputRowToGrid = [&](const sf::String& text, tgui::EditBox::Ptr& editBoxMember) {
        auto pair = createInputRowControls(text, INPUT_FIELD_WIDTH, INPUT_ROW_HEIGHT);
        if (!pair.first || !pair.second) {
            std::cerr << "Error: Failed to create input pair for: " << text.toAnsiString() << std::endl;
            return;
        }
        editBoxMember = pair.second;
        m_inputControlsGrid->addWidget(pair.first, currentRow, 0);
        m_inputControlsGrid->addWidget(editBoxMember, currentRow, 1);
        m_inputControlsGrid->setWidgetPadding(currentRow, 0, { 5, 5, 5, 0 });  // Label: T,R,B,L (0 слева, т.к. грид имеет свой отступ)
        m_inputControlsGrid->setWidgetPadding(currentRow, 1, { 5, 0, 5, 5 });  // EditBox: T,R,B,L (0 справа)
        currentRow++;
    };

    addInputRowToGrid(L"m (масса, кг):", m_edit_m);
    addInputRowToGrid(L"M (масса, кг):", m_edit_M);
    addInputRowToGrid(L"V0 (скорость, м/с):", m_edit_V0);
    addInputRowToGrid(L"T (время, сут):", m_edit_T);
    addInputRowToGrid(L"k (безразмерная):", m_edit_k);
    addInputRowToGrid(L"F (безразмерная):", m_edit_F);

    // 3. Кнопка "Рассчитать траекторию!"
    m_calculateButton = tgui::Button::create(L"Рассчитать траекторию!");
    if (!m_calculateButton) { std::cerr << "Error: Failed to create m_calculateButton" << std::endl; return; }
    m_calculateButton->getRenderer()->setRoundedBorderRadius(15);
    m_calculateButton->setSize({ "100% - " + tgui::String::fromNumber(2 * PANEL_PADDING), 40 });
    m_calculateButton->setPosition({ PANEL_PADDING, tgui::bindBottom(m_inputControlsGrid) + WIDGET_SPACING * 1.5f }); // Больший отступ для кнопки
    m_leftPanel->add(m_calculateButton);


    // 4. НОВАЯ Кнопка "Открыть визуализатор"
    m_showVisualizerButton = tgui::Button::create(L"Открыть 3D визуализатор"); // Текст можно изменить
    if (!m_showVisualizerButton) { std::cerr << "Error: Failed to create m_showVisualizerButton" << std::endl; return; }
    m_showVisualizerButton->getRenderer()->setRoundedBorderRadius(15);
    m_showVisualizerButton->setSize({ "100% - " + tgui::String::fromNumber(2 * PANEL_PADDING), 40 });
    // Позиционируем относительно предыдущей кнопки
    m_showVisualizerButton->setPosition({ PANEL_PADDING, tgui::bindBottom(m_calculateButton) + WIDGET_SPACING / 2.0f });
    m_leftPanel->add(m_showVisualizerButton);
}

void UserInterface::loadRightPanelWidgets() {
    m_rightPanel = tgui::Panel::create();
    if (!m_rightPanel) { std::cerr << "Error: Failed to create m_rightPanel" << std::endl; return; }
    m_gui.add(m_rightPanel); // Сначала добавляем, потом настраиваем содержимое

    loadTrajectoryWidgets(m_rightPanel);
    loadTableWidgets(m_rightPanel);
}

void UserInterface::loadTrajectoryWidgets(tgui::Panel::Ptr parentPanel) {
    m_trajectoryContainerPanel = tgui::Panel::create();
    if (!m_trajectoryContainerPanel) { std::cerr << "Error: Failed to create m_trajectoryContainerPanel" << std::endl; return; }
    m_trajectoryContainerPanel->getRenderer()->setBorders({ 1,1,1,1 });
    m_trajectoryContainerPanel->getRenderer()->setBorderColor(tgui::Color::Black);
    m_trajectoryContainerPanel->getRenderer()->setBackgroundColor(tgui::Color::White);
    parentPanel->add(m_trajectoryContainerPanel);

    m_trajectoryTitleLabel = tgui::Label::create(L"Траектория движения тела");
    if (!m_trajectoryTitleLabel) { std::cerr << "Error: Failed to create m_trajectoryTitleLabel" << std::endl; return; }
    m_trajectoryTitleLabel->getRenderer()->setTextStyle(tgui::TextStyle::Bold);
    m_trajectoryTitleLabel->setHorizontalAlignment(tgui::Label::HorizontalAlignment::Center);
    m_trajectoryTitleLabel->getRenderer()->setTextColor(tgui::Color::Black);
    m_trajectoryTitleLabel->setSize({ "100%", TITLE_HEIGHT });
    m_trajectoryContainerPanel->add(m_trajectoryTitleLabel, "TrajectoryTitle"); // Используем имя для позиционирования канваса

    m_trajectoryCanvas = tgui::Canvas::create();
    if (!m_trajectoryCanvas) { std::cerr << "Error: Failed to create m_trajectoryCanvas" << std::endl; return; }
    m_trajectoryCanvas->setSize({ "100%", "100% - " + tgui::String::fromNumber(TITLE_HEIGHT) });
    m_trajectoryCanvas->setPosition({ 0, "TrajectoryTitle.bottom" });
    m_trajectoryContainerPanel->add(m_trajectoryCanvas);
}

void UserInterface::loadTableWidgets(tgui::Panel::Ptr parentPanel) {
    m_tableContainerPanel = tgui::Panel::create();
    if (!m_tableContainerPanel) { std::cerr << "Error: Failed to create m_tableContainerPanel" << std::endl; return; }
    m_tableContainerPanel->getRenderer()->setBorders({ 1,1,1,1 });
    m_tableContainerPanel->getRenderer()->setBorderColor(tgui::Color::Black);
    m_tableContainerPanel->getRenderer()->setBackgroundColor(tgui::Color::White);
    parentPanel->add(m_tableContainerPanel);

    m_tableTitleLabel = tgui::Label::create(L"Таблица координат и скоростей");
    if (!m_tableTitleLabel) { std::cerr << "Error: Failed to create m_tableTitleLabel" << std::endl; return; }
    m_tableTitleLabel->getRenderer()->setTextStyle(tgui::TextStyle::Bold);
    m_tableTitleLabel->setHorizontalAlignment(tgui::Label::HorizontalAlignment::Center);
    m_tableTitleLabel->getRenderer()->setTextColor(tgui::Color::Black);
    m_tableTitleLabel->setSize({ "100%", TITLE_HEIGHT });
    m_tableContainerPanel->add(m_tableTitleLabel, "TableTitle");

    m_tableHeaderGrid = tgui::Grid::create();
    if (!m_tableHeaderGrid) { std::cerr << "Error: Failed to create m_tableHeaderGrid" << std::endl; return; }
    m_tableHeaderGrid->setSize({ "100% - " + tgui::String::fromNumber(SCROLLBAR_WIDTH_ESTIMATE), HEADER_HEIGHT });
    m_tableHeaderGrid->setPosition({ 0, "TableTitle.bottom" });

    std::vector<sf::String> headers = { L"h, сут", L"x", L"y", L"Vx", L"Vy" };
    for (size_t i = 0; i < headers.size(); ++i) {
        auto headerLabel = tgui::Label::create(tgui::String(headers[i]));
        if (!headerLabel) { std::cerr << "Error: Failed to create headerLabel " << i << std::endl; continue; }
        
        headerLabel->getRenderer()->setTextColor(tgui::Color::Black);
        headerLabel->getRenderer()->setBorders({ 0,0,0,1 }); // Только нижняя граница
        headerLabel->getRenderer()->setBorderColor(tgui::Color::Black);
        headerLabel->setHorizontalAlignment(tgui::Label::HorizontalAlignment::Center);
        headerLabel->setVerticalAlignment(tgui::Label::VerticalAlignment::Center);
        m_tableHeaderGrid->addWidget(headerLabel, 0, i);
        
        // Можно добавить отступы для headerLabel, если нужно
        // m_tableHeaderGrid->setWidgetPadding(0, i, {2,5,2,5}); // T,R,B,L
    }
    m_tableContainerPanel->add(m_tableHeaderGrid);

    m_tableDataPanel = tgui::ScrollablePanel::create();
    if (!m_tableDataPanel) { std::cerr << "Error: Failed to create m_tableDataPanel" << std::endl; return; }
    m_tableDataPanel->setSize({ "100%", "100% - " + tgui::String::fromNumber(TITLE_HEIGHT + HEADER_HEIGHT) });
    m_tableDataPanel->setPosition({ 0, tgui::bindBottom(m_tableHeaderGrid) });
    m_tableDataPanel->getRenderer()->setBackgroundColor(tgui::Color(245, 245, 245));
    m_tableContainerPanel->add(m_tableDataPanel);

    m_tableDataGrid = tgui::Grid::create();
    if (!m_tableDataGrid) { std::cerr << "Error: Failed to create m_tableDataGrid for data" << std::endl; return; }
    // Ширина и высота m_tableDataGrid будут управляться ScrollablePanel и его содержимым
    m_tableDataPanel->add(m_tableDataGrid);
}

// --- Компоновка ---
void UserInterface::setupLayout() {
    std::cout << "DEBUG: Setting up layout..." << std::endl;
    // Левая панель
    m_leftPanel->setSize({ "30%", "100%" }); // Немного шире для комфорта
    m_leftPanel->setPosition({ 0, 0 });

    // Правая панель
    m_rightPanel->setSize({ "70%", "100%" });
    m_rightPanel->setPosition({ "30%", 0 });

    // Контейнеры внутри правой панели
    const float rightPanelPadding = PANEL_PADDING;
    const float verticalSpacing = WIDGET_SPACING / 2.f;

    m_trajectoryContainerPanel->setSize(
        { tgui::bindWidth(m_rightPanel) - 2 * rightPanelPadding,
         "60% - " + tgui::String::fromNumber(rightPanelPadding + verticalSpacing / 2.f) 
        }
    );
    m_trajectoryContainerPanel->setPosition({ rightPanelPadding, rightPanelPadding });

    m_tableContainerPanel->setSize(
        { tgui::bindWidth(m_rightPanel) - 2 * rightPanelPadding,
         "40% - " + tgui::String::fromNumber(rightPanelPadding + verticalSpacing / 2.f) 
        }
    );
    m_tableContainerPanel->setPosition({ rightPanelPadding, tgui::bindBottom(m_trajectoryContainerPanel) + verticalSpacing });
    std::cout << "DEBUG: Layout setup finished." << std::endl;
}

// --- Подключение сигналов ---
void UserInterface::connectSignals() {
    if (m_calculateButton) {
        // Используем .connect() для TGUI 0.9.x
        m_calculateButton->onPress.connect(&UserInterface::onCalculateButtonPressed, this);
    }
    else {
        std::cerr << "Error: m_calculateButton is null in connectSignals! Cannot connect." << std::endl;
    }

    // Подключаем сигнал для новой кнопки
    if (m_showVisualizerButton) {
        m_showVisualizerButton->onPress.connect(&UserInterface::onShowVisualizerButtonPressed, this);
    }
    else {
        std::cerr << "Error: m_showVisualizerButton is null in connectSignals! Cannot connect." << std::endl;
    }
}

// --- Обработчики и логика ---
void UserInterface::onCalculateButtonPressed() {
    std::cout << "Calculate button pressed!" << std::endl;

    // Физические константы
    const double G_SI = 6.67430e-11; // м^3 кг^-1 с^-2
    const double REFERENCE_PHYSICAL_LENGTH_FOR_X_1_5 = 1.495978707e11; // 1 AU в метрах
    const double SECONDS_PER_DAY = 24.0 * 60.0 * 60.0;

    SimulationParameters paramsFromUI;

    double M_ui_val_from_editbox = 1.0;
    double m_satellite_ui_kg = 100.0;    // Масса спутника, кг (значение по умолчанию)
    double V0_ui_si = 0.0;
    double T_total_ui_days = 1.0;
    double k_val_input = paramsFromUI.DRAG_COEFFICIENT;
    double F_val_input = paramsFromUI.THRUST_COEFFICIENT;

    try {
        if (m_edit_M && !m_edit_M->getText().empty())
            M_ui_val_from_editbox = std::stod(m_edit_M->getText().toStdString());
        else {
            std::cerr << "Warning: Central body mass (M) is empty. Using default 1.0 for input value." << std::endl;
            M_ui_val_from_editbox = 1.0;
        }

        // Чтение массы спутника m
        if (m_edit_m && !m_edit_m->getText().empty())
            m_satellite_ui_kg = std::stod(m_edit_m->getText().toStdString());
        else {
            std::cerr << "Warning: Satellite mass (m) is empty. Using default 100.0 kg." << std::endl;
            // m_satellite_ui_kg уже 100.0
        }

        if (m_satellite_ui_kg < 0) { // Проверка на отрицательную массу спутника
            std::cerr << "Error: Satellite mass (m) cannot be negative." << std::endl;
            if (m_inputTitleLabel) m_inputTitleLabel->setText(L"Масса спутника >= 0!");
            m_trajectoryAvailable = false; m_calculatedStates.clear();
            prepareTrajectoryForDisplay(); populateTable({});
            return;
        }


        if (m_edit_V0 && !m_edit_V0->getText().empty())
            V0_ui_si = std::stod(m_edit_V0->getText().toStdString());

        if (m_edit_T && !m_edit_T->getText().empty())
            T_total_ui_days = std::stod(m_edit_T->getText().toStdString());

        if (m_edit_k && !m_edit_k->getText().empty())
            k_val_input = std::stod(m_edit_k->getText().toStdString());

        if (m_edit_F && !m_edit_F->getText().empty())
            F_val_input = std::stod(m_edit_F->getText().toStdString());

    }
    catch (const std::exception& e) {
        std::cerr << "Error parsing input values: " << e.what() << std::endl;
        if (m_inputTitleLabel) m_inputTitleLabel->setText(L"Ошибка ввода параметров!");
        m_trajectoryAvailable = false; m_calculatedStates.clear();
        prepareTrajectoryForDisplay(); populateTable({});
        return;
    }
    if (m_inputTitleLabel) m_inputTitleLabel->setText(L"Исходные значения");

    // 1. Применяем модификатор к M_central и определяем масштабы
    double M_central_body_physical_kg = M_ui_val_from_editbox * 1.0e25;

    // Выбираем единицу массы для масштабирования:
    double mass_unit_for_scaling = M_central_body_physical_kg;

    double length_unit = REFERENCE_PHYSICAL_LENGTH_FOR_X_1_5 / paramsFromUI.initialState.x;

    if (mass_unit_for_scaling <= 1e-9) {
        std::cerr << "Error: Scaling mass unit (M_central_body_physical_kg) must be significantly positive." << std::endl;
        if (m_inputTitleLabel) m_inputTitleLabel->setText(L"Масса центр. тела > 0!");
        m_trajectoryAvailable = false; m_calculatedStates.clear();
        prepareTrajectoryForDisplay(); populateTable({});
        return;
    }
    // Масштаб времени зависит от G_SI и выбранной единицы массы для масштабирования
    double time_unit = std::sqrt(std::pow(length_unit, 3) / (G_SI * mass_unit_for_scaling));

    std::cout << "DEBUG SCALES: mass_unit_for_scaling=" << mass_unit_for_scaling << " kg, length_unit=" << length_unit << " m, time_unit=" << time_unit << " s" << std::endl;
    std::cout << "DEBUG MASSES: M_central_phys=" << M_central_body_physical_kg << " kg, m_satellite_phys=" << m_satellite_ui_kg << " kg" << std::endl;

    // 2. Заполнение структуры paramsFromUI безразмерными значениями

    paramsFromUI.G = 1.0;
    paramsFromUI.M = (M_central_body_physical_kg + m_satellite_ui_kg) / mass_unit_for_scaling;
    // Это эквивалентно: 1.0 + (m_satellite_ui_kg / M_central_body_physical_kg)

    std::cout << "DEBUG PARAMS: G_calc=" << paramsFromUI.G << ", M_calc_eff_for_gravity=" << paramsFromUI.M << std::endl;

    // Коэффициенты k и F:
    paramsFromUI.DRAG_COEFFICIENT = k_val_input;
    paramsFromUI.THRUST_COEFFICIENT = F_val_input;
    std::cout << "DEBUG PARAMS: DRAG_COEFF_calc=" << paramsFromUI.DRAG_COEFFICIENT << ", THRUST_COEFF_calc=" << paramsFromUI.THRUST_COEFFICIENT << std::endl;


    // Расчет STEPS и начальной скорости vy
    double T_total_ui_sec = T_total_ui_days * SECONDS_PER_DAY;
    double T_total_dimensionless = T_total_ui_sec / time_unit;

    if (paramsFromUI.DT > 1e-9) {
        paramsFromUI.STEPS = static_cast<int>(T_total_dimensionless / paramsFromUI.DT);
    }
    else {
        paramsFromUI.STEPS = 1000;
        std::cerr << "Warning: DT is too small or zero. Using default STEPS." << std::endl;
    }
    if (paramsFromUI.STEPS <= 0) paramsFromUI.STEPS = 1;

    std::cout << "DEBUG PARAMS: T_total_dimless=" << T_total_dimensionless << ", STEPS=" << paramsFromUI.STEPS << std::endl;

    double characteristic_velocity = length_unit / time_unit;
    if (std::abs(characteristic_velocity) > 1e-9) {
        paramsFromUI.initialState.vy = V0_ui_si / characteristic_velocity;
    }
    else {
        paramsFromUI.initialState.vy = 0.0;
        std::cerr << "Warning: Characteristic velocity (length_unit/time_unit) is near zero. Setting vy_dimless to 0." << std::endl;
    }
    std::cout << "DEBUG PARAMS: vy_dimless=" << paramsFromUI.initialState.vy << std::endl;

    // --- Остальная часть метода (вызов calculator.runSimulation и т.д.) без изменений ---
    Calculations calculator;
    m_calculatedStates = calculator.runSimulation(paramsFromUI);

    m_currentTableData.clear();
    if (!m_calculatedStates.empty()) {
        m_trajectoryAvailable = true;

        const size_t maxTableEntries = 100;
        size_t step_size_for_table = 1;

        if (m_calculatedStates.size() > maxTableEntries) {
            step_size_for_table = m_calculatedStates.size() / maxTableEntries;
            if (step_size_for_table == 0) step_size_for_table = 1;
        }

        for (size_t i = 0; i < m_calculatedStates.size(); i += step_size_for_table) {
            const auto& state = m_calculatedStates[i];
            double current_dimensionless_time = i * paramsFromUI.DT;
            double current_physical_time_sec = current_dimensionless_time * time_unit;
            double current_physical_time_days = current_physical_time_sec / SECONDS_PER_DAY;

            m_currentTableData.push_back({
                static_cast<float>(current_physical_time_days),
                static_cast<float>(state.x),
                static_cast<float>(state.y),
                static_cast<float>(state.vx),
                static_cast<float>(state.vy)
                });
        }
    }
    else {
        m_trajectoryAvailable = false;
    }

    prepareTrajectoryForDisplay();
    populateTable(m_currentTableData);
}




void UserInterface::prepareTrajectoryForDisplay() {
    m_trajectoryDisplayPoints.clear();
    if (!m_trajectoryAvailable || m_calculatedStates.empty()) {
        std::cout << "DEBUG: No trajectory to prepare for display." << std::endl;
        return;
    }

    m_trajectoryDisplayPoints.reserve(m_calculatedStates.size());
    for (const auto& state : m_calculatedStates) {
        m_trajectoryDisplayPoints.emplace_back(
            sf::Vector2f(static_cast<float>(state.x), static_cast<float>(-state.y)), // Y инвертируется для отображения
            sf::Color::Blue // Цвет линии траектории
        );
    }
    std::cout << "DEBUG: Trajectory display points prepared. Count: " << m_trajectoryDisplayPoints.size() << std::endl;
}

void UserInterface::drawTrajectoryOnCanvas(sf::RenderTarget& canvasRenderTarget) {
    sf::View originalView = canvasRenderTarget.getView();
    sf::View fittedView;

    if (m_trajectoryAvailable && !m_trajectoryDisplayPoints.empty()) {

        // 1. Рассчитываем ограничивающий прямоугольник (bounding box) для всего содержимого
        //    (точки траектории + начало координат (0,0) для центрального тела)
        float min_x_content = m_trajectoryDisplayPoints[0].position.x;
        float max_x_content = m_trajectoryDisplayPoints[0].position.x;
        float min_y_content = m_trajectoryDisplayPoints[0].position.y; // Будет <= 0
        float max_y_content = m_trajectoryDisplayPoints[0].position.y; // Будет >= min_y_content, может быть > 0 если траектория пересекает y_sim=0

        for (const auto& vertex : m_trajectoryDisplayPoints) {
            min_x_content = std::min(min_x_content, vertex.position.x);
            max_x_content = std::max(max_x_content, vertex.position.x);
            min_y_content = std::min(min_y_content, vertex.position.y);
            max_y_content = std::max(max_y_content, vertex.position.y);
        }

        // Убедимся, что (0,0) включено в bounding box
        min_x_content = std::min(min_x_content, 0.0f);
        max_x_content = std::max(max_x_content, 0.0f);
        min_y_content = std::min(min_y_content, 0.0f); // Если все y < 0, то max_y_content станет 0.0f
        max_y_content = std::max(max_y_content, 0.0f); // Если все y > 0 (не наш случай с инверсией), min_y_content станет 0.0f

        // Ширина и высота содержимого без отступов
        float content_width_no_padding = max_x_content - min_x_content;
        float content_height_no_padding = max_y_content - min_y_content; // Положительное число

        // 2. Добавляем отступы (padding)
        float paddingFactor = 0.1f; // 10% отступ

        // Базовые размеры для расчета процентного отступа.
        // Если контент очень маленький (точка), нужен минимальный абсолютный отступ.
        const float MIN_DIM_FOR_PERCENT_PADDING = 0.1f; // Если размер меньше этого, отступ будет от этого значения
        float base_width_for_padding = std::max(content_width_no_padding, MIN_DIM_FOR_PERCENT_PADDING);
        float base_height_for_padding = std::max(content_height_no_padding, MIN_DIM_FOR_PERCENT_PADDING);

        float padding_x = base_width_for_padding * paddingFactor;
        float padding_y = base_height_for_padding * paddingFactor;

        // Координаты отпадингованного прямоугольника
        float padded_min_x = min_x_content - padding_x;
        float padded_max_x = max_x_content + padding_x;
        float padded_min_y = min_y_content - padding_y; // Станет еще более отрицательным
        float padded_max_y = max_y_content + padding_y; // Станет еще более положительным (или дальше от нуля, если max_y_content был <0)

        // Фактические размеры отпадингованного контента
        float actual_padded_content_width = padded_max_x - padded_min_x;
        float actual_padded_content_height = padded_max_y - padded_min_y;

        // 3. Определяем "эффективные" размеры контента для расчета View.
        //    Это нужно, чтобы избежать деления на ноль или слишком маленьких размеров View.
        const float MIN_EFFECTIVE_VIEW_DIMENSION = 0.02f; // Минимальный размер стороны View в мировых координатах (чуть больше радиуса тела)
        float effective_view_content_width = std::max(actual_padded_content_width, MIN_EFFECTIVE_VIEW_DIMENSION);
        float effective_view_content_height = std::max(actual_padded_content_height, MIN_EFFECTIVE_VIEW_DIMENSION);

        // 4. Рассчитываем размеры sf::View, чтобы он соответствовал соотношению сторон канваса
        //    и вмещал effective_view_content_width/height.
        sf::Vector2u canvasSize = canvasRenderTarget.getSize();
        if (canvasSize.x == 0 || canvasSize.y == 0) {
            canvasRenderTarget.setView(originalView); // Размер канваса нулевой, ничего не рисуем
            return;
        }
        float canvasAspectRatio = static_cast<float>(canvasSize.x) / canvasSize.y;
        float effectiveContentAspectRatio = effective_view_content_width / effective_view_content_height;

        float view_width_world;  // Конечная ширина View в мировых координатах
        float view_height_world; // Конечная высота View в мировых координатах

        if (canvasAspectRatio > effectiveContentAspectRatio) {
            view_height_world = effective_view_content_height;
            view_width_world = view_height_world * canvasAspectRatio;
        }
        else {
            view_width_world = effective_view_content_width;
            view_height_world = view_width_world / canvasAspectRatio;
        }
        fittedView.setSize(view_width_world, view_height_world);

        // 5. Центрируем sf::View на центре *фактического* отпадингованного контента.
        //    Это ключевой момент. Центр должен быть от actual_padded_*, а не effective_*.
        sf::Vector2f actual_padded_content_center(
            padded_min_x + actual_padded_content_width / 2.0f,
            padded_min_y + actual_padded_content_height / 2.0f
        );
        fittedView.setCenter(actual_padded_content_center);

        canvasRenderTarget.setView(fittedView);

        // --- Отрисовка ---
        const float actual_central_body_radius = 0.01f; // Физический радиус
        sf::CircleShape centerBody(actual_central_body_radius);
        centerBody.setFillColor(sf::Color::Red);
        centerBody.setOrigin(actual_central_body_radius, actual_central_body_radius);
        centerBody.setPosition(0.f, 0.f);
        canvasRenderTarget.draw(centerBody);

        // m_trajectoryDisplayPoints уже проверен на !empty() в начале
        canvasRenderTarget.draw(m_trajectoryDisplayPoints.data(), m_trajectoryDisplayPoints.size(), sf::LineStrip);
    }
    else {
        // ... (код для placeholder текста) ...
        canvasRenderTarget.setView(canvasRenderTarget.getDefaultView());
        sf::Text placeholderText;
        if (m_sfmlFont.hasGlyph(L'Т')) { // Проверяем, загрузился ли шрифт
            placeholderText.setFont(m_sfmlFont);
            placeholderText.setString(L"Траектория не рассчитана.\nНажмите 'Рассчитать траекторию!'");
        }
        else {
            placeholderText.setString("Trajectory not calculated.\nPress 'Calculate Trajectory!' (Font error)"); // Фоллбэк
        }
        placeholderText.setCharacterSize(16);
        placeholderText.setFillColor(sf::Color(105, 105, 105));
        sf::FloatRect textRect = placeholderText.getLocalBounds();
        placeholderText.setOrigin(textRect.left + textRect.width / 2.0f, textRect.top + textRect.height / 2.0f);
        placeholderText.setPosition(static_cast<float>(canvasRenderTarget.getSize().x) / 2.0f,
            static_cast<float>(canvasRenderTarget.getSize().y) / 2.0f);
        canvasRenderTarget.draw(placeholderText);
    }
    canvasRenderTarget.setView(originalView); // Восстанавливаем исходный View
}

void UserInterface::onShowVisualizerButtonPressed() {
    std::cout << "Show Visualizer button pressed!" << std::endl;

    if (!m_trajectoryAvailable || m_calculatedStates.empty()) {
        std::cerr << "UserInterface: No trajectory data to visualize. Please calculate first." << std::endl;
        // Можно показать пользователю сообщение в GUI, если нужно
        // Например, временно изменить текст m_inputTitleLabel
        if (m_inputTitleLabel) {
            m_inputTitleLabel->setText(L"Сначала рассчитайте траекторию!");
            // Можно запустить таймер, чтобы через пару секунд вернуть текст обратно,
            // или пользователь сам поймет, когда нажмет "Рассчитать".
        }
        return;
    }

    // Преобразуем m_calculatedStates (std::vector<State>) 
    // в WorldTrajectoryData (std::vector<std::pair<double, double>>)
    WorldTrajectoryData trajectoryForVisualizer;
    trajectoryForVisualizer.reserve(m_calculatedStates.size());
    for (const auto& state : m_calculatedStates) {
        // TrajectoryVisualizer ожидает безразмерные координаты x, y,
        // так как он сам занимается их масштабированием для отображения.
        // Наши m_calculatedStates уже хранят безразмерные x и y.
        trajectoryForVisualizer.emplace_back(state.x, state.y);
    }

    if (trajectoryForVisualizer.empty()) {
        std::cerr << "UserInterface: Conversion to WorldTrajectoryData resulted in empty data." << std::endl;
        return;
    }

    std::cout << "UserInterface: Launching TrajectoryVisualizer with "
        << trajectoryForVisualizer.size() << " points." << std::endl;

    // Создаем и запускаем визуализатор
    // Размеры окна визуализатора можно сделать настраиваемыми или взять из констант
    try {
        TrajectoryVisualizer visualizer(1000, 800, "Standalone 2D Trajectory Visualizer");
        visualizer.setData(trajectoryForVisualizer);
        visualizer.run(); // Этот вызов блокирует выполнение здесь, пока окно visualizer не закроется
    }
    catch (const std::exception& e) {
        std::cerr << "UserInterface: Exception while running TrajectoryVisualizer: " << e.what() << std::endl;
        // Обработка ошибки, если создание или запуск TrajectoryVisualizer не удались
    }
    std::cout << "UserInterface: TrajectoryVisualizer window closed." << std::endl;
    // После закрытия окна визуализатора можно вернуть фокус или обновить что-то в основном UI, если нужно.
    if (m_inputTitleLabel && m_inputTitleLabel->getText() == L"Сначала рассчитайте траекторию!") {
        m_inputTitleLabel->setText(L"Исходные значения"); // Вернуть исходный текст, если он был изменен
    }
}

void UserInterface::populateTable(const std::vector<TableRowData>& data) {
    if (!m_tableDataGrid) { std::cerr << "Error: m_tableDataGrid is null in populateTable!" << std::endl; return; }
    m_tableDataGrid->removeAllWidgets();

    if (data.empty()) {
        auto emptyLabel = tgui::Label::create(L"Нет данных для отображения");
        if (emptyLabel) {
            emptyLabel->setHorizontalAlignment(tgui::Label::HorizontalAlignment::Center);
            m_tableDataGrid->addWidget(emptyLabel, 0, 0);
            // Чтобы emptyLabel занимал все 5 колонок, если API Grid не позволяет colspan:
            // for (unsigned int j = 1; j < 5; ++j) {
            //     m_tableDataGrid->addWidget(tgui::Label::create(""), 0, j); // Пустые метки
            // }
        }
        if (m_tableDataPanel) m_tableDataPanel->setContentSize({ 0,0 });
        return;
    }

    size_t step = 1;
    if (data.size() > 100) { // Пример: если точек больше 100, показываем примерно 100 строк
        step = data.size() / 100;
    }
    if (step == 0) step = 1; // На всякий случай

    for (size_t i = 0; i < data.size(); i += step) {
        const auto& rowData = data[i];
        std::stringstream ss_h, ss_x, ss_y, ss_vx, ss_vy;
        ss_h << std::fixed << std::setprecision(2) << rowData.h_days;
        ss_x << std::fixed << std::setprecision(2) << rowData.x;
        ss_y << std::fixed << std::setprecision(2) << rowData.y;
        ss_vx << std::fixed << std::setprecision(2) << rowData.Vx;
        ss_vy << std::fixed << std::setprecision(2) << rowData.Vy;
        std::vector<tgui::String> rowStrings = {
            tgui::String(ss_h.str()), tgui::String(ss_x.str()), tgui::String(ss_y.str()),
            tgui::String(ss_vx.str()), tgui::String(ss_vy.str()) };

        for (size_t j = 0; j < rowStrings.size(); ++j) {
            auto cellLabel = tgui::Label::create(rowStrings[j]);
            if (cellLabel) {
                cellLabel->getRenderer()->setTextColor(tgui::Color::Black);
                cellLabel->setHorizontalAlignment(tgui::Label::HorizontalAlignment::Center);
                m_tableDataGrid->addWidget(cellLabel, i, j);
                m_tableDataGrid->setWidgetPadding(i, j, { 2, 5, 2, 5 });
            }
        }
    }
    if (m_tableDataPanel && m_tableDataGrid) {
        m_tableDataPanel->setContentSize(m_tableDataGrid->getSize());
    }
}

// --- Главный цикл и обработка событий ---
void UserInterface::run() {
    m_window.setFramerateLimit(60); // Ограничение FPS для плавности и снижения нагрузки
    while (m_window.isOpen()) {
        handleEvents();
        update();
        render();
    }
}

void UserInterface::handleEvents() {
    sf::Event event;
    while (m_window.pollEvent(event)) {
        // 1. СНАЧАЛА передаем событие в TGUI для его внутренней обработки.
        //    TGUI сама обработает sf::Event::Resized для своих нужд,
        //    если окно, на которое она нацелена, имеет обновленный View.
        m_gui.handleEvent(event);

        // 2. Затем наша пользовательская обработка событий
        if (event.type == sf::Event::Closed) {
            m_window.close();
        }
        else if (event.type == sf::Event::Resized) {
            // Окно SFML изменило размер.
            // Обновляем View для самого окна SFML.
            // TGUI, при вызове m_gui.draw(), будет рисовать в текущий View окна.
            sf::FloatRect visibleArea(0.f, 0.f, static_cast<float>(event.size.width), static_cast<float>(event.size.height));
            m_window.setView(sf::View(visibleArea));

            // Отладочный вывод:
            std::cout << "DEBUG: Window Resized to: " << event.size.width << "x" << event.size.height
                << ". SFML Window View updated." << std::endl;
        }
        // Другие ваши обработчики событий
    }
}

void UserInterface::update() {
    // Например, анимация или другие обновления состояния, не связанные с вводом пользователя
}

void UserInterface::render() {
    if (m_trajectoryCanvas) {
        sf::RenderTexture& canvasRT = m_trajectoryCanvas->getRenderTexture();
        sf::Vector2f canvasWidgetSize = m_trajectoryCanvas->getSize(); // Размер виджета TGUI

        if (canvasRT.getSize().x != static_cast<unsigned int>(canvasWidgetSize.x) ||
            canvasRT.getSize().y != static_cast<unsigned int>(canvasWidgetSize.y)) {

            std::cout << "DEBUG: Canvas RenderTexture size (" << canvasRT.getSize().x << "x" << canvasRT.getSize().y
                << ") differs from TGUI Widget size (" << canvasWidgetSize.x << "x" << canvasWidgetSize.y
                << "). Recreating RenderTexture for Canvas." << std::endl;

            if (canvasWidgetSize.x > 0 && canvasWidgetSize.y > 0) {
                if (!canvasRT.create(static_cast<unsigned int>(canvasWidgetSize.x), static_cast<unsigned int>(canvasWidgetSize.y))) {
                    std::cerr << "ERROR: Failed to recreate Canvas RenderTexture!" << std::endl;
                }
            }
            else {
                std::cout << "DEBUG: Canvas widget size is zero, not recreating RenderTexture." << std::endl;
            }
        }

        canvasRT.clear(sf::Color(250, 250, 250)); // Фон канваса
        drawTrajectoryOnCanvas(canvasRT);      // Этот метод теперь сам устанавливает и сбрасывает View
        m_trajectoryCanvas->display();
    }
    m_window.clear(sf::Color(220, 220, 220));
    m_gui.draw();
    m_window.display();
}

#include "Calculations.h"         // Для расчетов
#include "TrajectoryVisualizer.h" // Для визуализации
#include "UserInterface.h"        // Для вашего TGUI интерфейса

#include <iostream>
#include <string>
#include <stdexcept>   // Для tgui::Exception и std::exception
#include <iomanip>     // Для std::fixed, std::setprecision в saveTrajectoryToFile
#include <fstream>     // Для std::ofstream в saveTrajectoryToFile

void saveTrajectoryToFile(const WorldTrajectoryData& trajectoryData, const std::string& filename);


int main() {
    setlocale(LC_ALL, "Rus");

    // 1. ОКНО ПРОГРАММЫ //

    try {
        UserInterface uiApp;
        uiApp.run();
    }
    catch (const tgui::Exception& e) {
        std::cerr << "TGUI Exception: " << e.what() << std::endl;
        return EXIT_FAILURE;
    }
    catch (const std::runtime_error& e) {
        std::cerr << "Runtime Exception: " << e.what() << std::endl;
        return EXIT_FAILURE;
    }
    catch (const std::exception& e) {
        std::cerr << "Standard Exception: " << e.what() << std::endl;
        return EXIT_FAILURE;
    }
    catch (...) {
        std::cerr << "An unknown C++ exception occurred." << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}


void saveTrajectoryToFile(const WorldTrajectoryData& trajectoryData, const std::string& filename) {
    std::ofstream fout(filename);
    if (!fout.is_open()) {
        std::cerr << "Ошибка: не удалось открыть файл '" << filename << "' для записи.\n";
        return;
    }
    // Используем высокую точность для сохранения данных
    fout << std::fixed << std::setprecision(10);
    for (const auto& point : trajectoryData) {
        fout << point.first << " " << point.second << "\n";
    }
    fout.close();
    std::cout << "Результаты симуляции (" << trajectoryData.size() << " точек) записаны в " << filename << "\n";
}
